/* Copyright 2009-2011 David Hadka
 * 
 * This file is part of the MOEA Framework.
 * 
 * The MOEA Framework is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by 
 * the Free Software Foundation, either version 3 of the License, or (at your 
 * option) any later version.
 * 
 * The MOEA Framework is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License 
 * along with the MOEA Framework.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.moeaframework.studies.sobol;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;
import org.apache.commons.cli.CommandLine;
import org.moeaframework.analysis.sensitivity.MetricFileReader;
import org.moeaframework.analysis.sensitivity.ParameterFile;
import org.moeaframework.core.PRNG;
import org.moeaframework.util.ArrayMath;
import org.moeaframework.util.CommandLineUtility;

/**
 * Global sensitivity analysis of blackbox model output using Saltelli's
 * improved Sobol' global variance decomposition procedure.
 * <p>
 * The following code was derived and translated from the C code used in the
 * study cited below. Refer to this article for a description of the procedure.
 * <p>
 * References:
 * <ol>
 * <li>Tang, Y., Reed, P., Wagener, T., and van Werkhoven, K., "Comparing
 * Sensitivity Analysis Methods to Advance Lumped Watershed Model Identification
 * and Evaluation," Hydrology and Earth System Sciences, vol. 11, no. 2, pp.
 * 793-817, 2007.
 * <li>Saltelli, A., et al. "Global Sensitivity Analysis: The Primer." John
 * Wiley & Sons Ltd, 2008.
 * </ol>
 */
public class SobolAnalysis extends CommandLineUtility {

	/**
	 * Number of resamples used to bootstrap the 50% confidence intervals.
	 */
	private static int nresample = 1000;

	/**
	 * Parameters being analyzed.
	 */
	private ParameterFile parameterFile;

	/**
	 * Number of parameters.
	 */
	private int P;

	/**
	 * Number of samples.
	 */
	private int N;

	/**
	 * Output from the original parameters.
	 */
	private double[] A;

	/**
	 * Output from the resampled parameters.
	 */
	private double[] B;

	/**
	 * Output from the original samples where the j-th parameter is replaced by
	 * the corresponding resampled parameter.
	 */
	private double[][] C_A;

	/**
	 * Output from the resampled samples where the j-th parameter is replaced by
	 * the corresponding original parameter.
	 */
	private double[][] C_B;

	/**
	 * Private constructor to prevent instantiation.
	 */
	private SobolAnalysis() {
		super();
	}

	/**
	 * Loads the outputs from the file. Each line in the file must contain the
	 * output produced using the parameters generated by SobolSequence.
	 * 
	 * @param metricFile
	 * @throws IOException
	 */
	private void load(File metricFile) throws IOException {
		BufferedReader reader = null;
		try {
			reader = new BufferedReader(new FileReader(metricFile));

			A = new double[N];
			B = new double[N];
			C_A = new double[N][P];
			C_B = new double[N][P];

			for (int i = 0; i < N; i++) {
				A[i] = Double.parseDouble(reader.readLine());

				for (int j = 0; j < P; j++) {
					C_A[i][j] = Double.parseDouble(reader.readLine());
				}

				for (int j = 0; j < P; j++) {
					C_B[i][j] = Double.parseDouble(reader.readLine());
				}

				B[i] = Double.parseDouble(reader.readLine());
			}
		} finally {
			if (reader != null) {
				reader.close();
			}
		}
	}

	/**
	 * Computes and displays the first-, total-, and second- order Sobol'
	 * sensitivites and 50% bootstrap confidence intervals.
	 */
	public void display() {
		System.out.println("Parameter	Sensitivity [Confidence]");

		System.out.println("First-Order Effects");
		for (int j = 0; j < P; j++) {
			double[] a0 = new double[N];
			double[] a1 = new double[N];
			double[] a2 = new double[N];

			for (int i = 0; i < N; i++) {
				a0[i] = A[i];
				a1[i] = C_A[i][j];
				a2[i] = B[i];
			}

			System.out.println("  " + parameterFile.get(j).getName() + " "
					+ computeFirstOrder(a0, a1, a2, N) + " ["
					+ computeFirstOrderConfidence(a0, a1, a2, N, nresample)
					+ "]");
		}

		System.out.println("Total-Order Effects");
		for (int j = 0; j < P; j++) {
			double[] a0 = new double[N];
			double[] a1 = new double[N];
			double[] a2 = new double[N];

			for (int i = 0; i < N; i++) {
				a0[i] = A[i];
				a1[i] = C_A[i][j];
				a2[i] = B[i];
			}

			System.out.println("  " + parameterFile.get(j).getName() + " "
					+ computeTotalOrder(a0, a1, a2, N) + " ["
					+ computeTotalOrderConfidence(a0, a1, a2, N, nresample)
					+ "]");
		}

		System.out.println("Second-Order Effects");
		for (int j = 0; j < P; j++) {
			for (int k = j + 1; k < P; k++) {
				double[] a0 = new double[N];
				double[] a1 = new double[N];
				double[] a2 = new double[N];
				double[] a3 = new double[N];
				double[] a4 = new double[N];

				for (int i = 0; i < N; i++) {
					a0[i] = A[i];
					a1[i] = C_B[i][j];
					a2[i] = C_A[i][k];
					a3[i] = C_A[i][j];
					a4[i] = B[i];
				}

				System.out.println("  "
						+ parameterFile.get(j).getName()
						+ " * "
						+ parameterFile.get(k).getName()
						+ " "
						+ computeSecondOrder(a0, a1, a2, a3, a4, N)
						+ " ["
						+ computeSecondOrderConfidence(a0, a1, a2, a3, a4, N,
								nresample) + "]");
			}
		}
	}

	/**
	 * Computes and displays the first- and total-order Sobol' sensitivites and
	 * 50% bootstrap confidence intervals.
	 */
	public void displaySimple() {
		System.out.println("First-Order Effects");
		for (int j = 0; j < P; j++) {
			double[] a0 = new double[N];
			double[] a1 = new double[N];
			double[] a2 = new double[N];

			for (int i = 0; i < N; i++) {
				a0[i] = A[i];
				a1[i] = C_A[i][j];
				a2[i] = B[i];
			}

			double value = computeFirstOrder(a0, a1, a2, N);
			System.out.print(value < 0 ? 0.0 : value);

			if (j < P - 1) {
				System.out.print('\t');
			}
		}

		System.out.println();
		System.out.println("Total-Order Effects");
		for (int j = 0; j < P; j++) {
			double[] a0 = new double[N];
			double[] a1 = new double[N];
			double[] a2 = new double[N];

			for (int i = 0; i < N; i++) {
				a0[i] = A[i];
				a1[i] = C_A[i][j];
				a2[i] = B[i];
			}

			double value = computeTotalOrder(a0, a1, a2, N);
			System.out.print(value < 0 ? 0.0 : value);

			if (j < P - 1) {
				System.out.print('\t');
			}
		}

		System.out.println();
	}

	private static double computeFirstOrderConfidence(double[] a0, double[] a1,
			double[] a2, int nsample, int nresample) {
		double[] b0 = new double[nsample];
		double[] b1 = new double[nsample];
		double[] b2 = new double[nsample];

		double[] s = new double[nresample];

		for (int i = 0; i < nresample; i++) {
			for (int j = 0; j < nsample; j++) {
				int index = PRNG.nextInt(nsample);

				b0[j] = a0[index];
				b1[j] = a1[index];
				b2[j] = a2[index];
			}

			s[i] = computeFirstOrder(b0, b1, b2, nsample);
		}

		double ss = ArrayMath.sum(s) / nresample;
		double sss = 0.0;
		for (int i = 0; i < nresample; i++) {
			sss += Math.pow(s[i] - ss, 2.0);
		}

		return 1.96 * Math.sqrt(sss / (nresample - 1));
	}

	private static double computeFirstOrder(double[] a0, double[] a1,
			double[] a2, int nsample) {
		double c = 0.0;
		for (int i = 0; i < nsample; i++) {
			c += a0[i];
		}
		c /= nsample;

		double tmp1 = 0.0;
		double tmp2 = 0.0;
		double tmp3 = 0.0;
		double EY2 = 0.0;

		for (int i = 0; i < nsample; i++) {
			EY2 += (a0[i] - c) * (a2[i] - c);
			tmp1 += (a2[i] - c) * (a2[i] - c);
			tmp2 += (a2[i] - c);
			tmp3 += (a1[i] - c) * (a2[i] - c);
		}

		EY2 /= nsample;

		double V = (tmp1 / (nsample - 1)) - Math.pow(tmp2 / nsample, 2.0);
		double U = tmp3 / (nsample - 1);

		return (U - EY2) / V;
	}

	private static double computeTotalOrder(double[] a0, double[] a1,
			double[] a2, int nsample) {
		double c = 0.0;
		for (int i = 0; i < nsample; i++) {
			c += a0[i];
		}
		c /= nsample;

		double tmp1 = 0.0;
		double tmp2 = 0.0;
		double tmp3 = 0.0;

		for (int i = 0; i < nsample; i++) {
			tmp1 += (a0[i] - c) * (a0[i] - c);
			tmp2 += (a0[i] - c) * (a1[i] - c);
			tmp3 += (a0[i] - c);
		}

		double EY2 = Math.pow(tmp3 / nsample, 2.0);
		double V = (tmp1 / (nsample - 1)) - EY2;
		double U = tmp2 / (nsample - 1);

		return 1.0 - ((U - EY2) / V);
	}

	private static double computeTotalOrderConfidence(double[] a0, double[] a1,
			double[] a2, int nsample, int nresample) {
		double[] b0 = new double[nsample];
		double[] b1 = new double[nsample];
		double[] b2 = new double[nsample];

		double[] s = new double[nresample];

		for (int i = 0; i < nresample; i++) {
			for (int j = 0; j < nsample; j++) {
				int index = PRNG.nextInt(nsample);

				b0[j] = a0[index];
				b1[j] = a1[index];
				b2[j] = a2[index];
			}

			s[i] = computeTotalOrder(b0, b1, b2, nsample);
		}

		double ss = ArrayMath.sum(s) / nresample;
		double sss = 0.0;
		for (int i = 0; i < nresample; i++) {
			sss += Math.pow(s[i] - ss, 2.0);
		}

		return 1.96 * Math.sqrt(sss / (nresample - 1));
	}

	private static double computeSecondOrder(double[] a0, double[] a1,
			double[] a2, double[] a3, double[] a4, int nsample) {
		double c = 0.0;
		for (int i = 0; i < nsample; i++) {
			c += a0[i];
		}
		c /= nsample;

		double EY = 0.0;
		double EY2 = 0.0;
		double tmp1 = 0.0;
		double tmp2 = 0.0;
		double tmp3 = 0.0;
		double tmp4 = 0.0;
		double tmp5 = 0.0;

		for (int i = 0; i < nsample; i++) {
			EY += (a0[i] - c) * (a4[i] - c);
			EY2 += (a1[i] - c) * (a3[i] - c);
			tmp1 += (a1[i] - c) * (a1[i] - c);
			tmp2 += (a1[i] - c);
			tmp3 += (a1[i] - c) * (a2[i] - c);
			tmp4 += (a2[i] - c) * (a4[i] - c);
			tmp5 += (a3[i] - c) * (a4[i] - c);
		}

		EY /= nsample;
		EY2 /= nsample;

		double V = (tmp1 / (nsample - 1)) - Math.pow(tmp2 / nsample, 2.0);
		double Vij = (tmp3 / (nsample - 1)) - EY2;
		double Vi = (tmp4 / (nsample - 1)) - EY;
		double Vj = (tmp5 / (nsample - 1)) - EY2;

		return (Vij - Vi - Vj) / V;
	}

	private static double computeSecondOrderConfidence(double[] a0,
			double[] a1, double[] a2, double[] a3, double[] a4, int nsample,
			int nresample) {
		double[] b0 = new double[nsample];
		double[] b1 = new double[nsample];
		double[] b2 = new double[nsample];
		double[] b3 = new double[nsample];
		double[] b4 = new double[nsample];

		double[] s = new double[nresample];

		for (int i = 0; i < nresample; i++) {
			for (int j = 0; j < nsample; j++) {
				int index = PRNG.nextInt(nsample);

				b0[j] = a0[index];
				b1[j] = a1[index];
				b2[j] = a2[index];
				b3[j] = a3[index];
				b4[j] = a4[index];
			}

			s[i] = computeSecondOrder(b0, b1, b2, b3, b4, nsample);
		}

		double ss = ArrayMath.sum(s) / nresample;
		double sss = 0.0;
		for (int i = 0; i < nresample; i++) {
			sss += Math.pow(s[i] - ss, 2.0);
		}

		return 1.96 * Math.sqrt(sss / (nresample - 1));
	}

	/**
	 * Ensures the metric file contains N*(2P+2) lines and returns N, the number
	 * of samples.
	 * 
	 * @param metricFile file being validated
	 * @return the number of samples
	 * @throws IOException
	 */
	private int validate(File metricFile) throws IOException {
		BufferedReader reader = null;
		try {
			reader = new BufferedReader(new FileReader(metricFile));
			int count = 0;

			while (reader.readLine() != null) {
				count++;
			}

			if (count % (2 * P + 2) != 0) {
				System.err.println(metricFile + " is incomplete");
			}

			return count / (2 * P + 2);
		} finally {
			if (reader != null) {
				reader.close();
			}
		}
	}

	@Override
	public void run(CommandLine commandLine) throws NumberFormatException,
	IOException {
		String algorithm = commandLine.getArgs()[0];
		for (int problem = 0; problem < Analysis.problems.length; problem++) {
			load(algorithm, Analysis.problems[problem]);

			parameterFile = new ParameterFile(new File("./params/" + algorithm + "_Params"));
			P = parameterFile.size();

			File metricFile = new File(algorithm + "_" + Analysis.problems[problem] + "_Results");
			N = validate(metricFile);
			load(metricFile);

			System.out.println(Analysis.problems[problem] + "\t" + N);

			for (int j = 0; j < P; j++) {
				double[] a0 = new double[N];
				double[] a1 = new double[N];
				double[] a2 = new double[N];

				for (int i = 0; i < N; i++) {
					a0[i] = A[i];
					a1[i] = C_A[i][j];
					a2[i] = B[i];
				}

				double first = Math.max(0.0, computeFirstOrder(a0, a1, a2, N));
				double firstError = computeFirstOrderConfidence(a0, a1, a2, N, nresample);
				double total = Math.max(0.0, computeTotalOrder(a0, a1, a2, N));
				double totalError = computeTotalOrderConfidence(a0, a1, a2, N, nresample);
				
				System.out.println("\t" + parameterFile.get(j).getName() + "\t" + first + "\t" + firstError + "\t" + (total-first) + "\t" + totalError);
			}

			//				System.out.println("Total-Order Effects");
			//				for (int j = 0; j < P; j++) {
			//					double[] a0 = new double[N];
			//					double[] a1 = new double[N];
			//					double[] a2 = new double[N];
			//
			//					for (int i = 0; i < N; i++) {
			//						a0[i] = A[i];
			//						a1[i] = C_A[i][j];
			//						a2[i] = B[i];
			//					}
			//
			//					double value = computeTotalOrder(a0, a1, a2, N);
			//					System.out.print(value < 0 ? 0.0 : value);
			//
			//					if (j < P - 1) {
			//						System.out.print('\t');
			//					}
			//				}
		}
	}
	
	private static void load(String algorithm, String problem) throws IOException {
		int metric = 0;
		ParameterFile parameterFile = new ParameterFile(new File("./params/" + algorithm + "_Params"));
		MetricFileReader metricReader = null;

		List<Double> metricList = new ArrayList<Double>();

		int count = 0;

		for (int i=0; i<=9; i++) {
			try {
				boolean good = false;
				File file = new File("./scratch/" + algorithm + "_" + problem + "_" + 0 + "_" + i);

				if (!file.exists()) {
					break;
				}

				while (count < SobolJobFactory.N*i) {
					count++;
				}

				metricReader = new MetricFileReader(file);

				while (metricReader.hasNext()) {
					double value = metricReader.next()[metric];

					if (count % (2*parameterFile.size() + 2) == 0) {
						good = true;
					}

					count++;

					if (metric == 0) {
						if (value < 0.0) {
							value = 0.0;
						} else if (value > 1.0) {
							value = 1.0;
						}
					} else if ((metric == 1) || (metric == 4)) {
						value = Math.max(0.0, 1.0 - value);

						//cutoff gd and eps indicator values to the range [0, 1]
						value = Math.max(0.0, value);
						value = Math.min(1.0, value);
					}

					if (good) {
						metricList.add(value);
					}

				}

				if (count != SobolJobFactory.N*(i+1)-1) {
					while (metricList.size() % (2*parameterFile.size() + 2) != 0) {
						metricList.remove(metricList.size()-1);
					}
				}
			} finally {
				if (metricReader != null) {
					metricReader.close();
				}
			}
		}
		
		while (metricList.size() % (2*parameterFile.size() + 2) != 0) {
			metricList.remove(metricList.size()-1);
		}

		File file = new File(algorithm + "_" + problem + "_Results");
		PrintWriter writer = new PrintWriter(file);
		for (int i=0; i<metricList.size(); i++) {
			writer.println(metricList.get(i));
		}
		writer.close();
	}

	/**
	 * Command line utility for global sensitivity analysis using Sobol's global
	 * variance decomposition based on Saltelli's work.
	 * 
	 * @param args the command line arguments
	 */
	public static void main(String[] args) {
		new SobolAnalysis().start(args);
	}

}
